;; ═══════════════════════════════════════════════════════════════════════════════
;; MONOFACTURE DEAL ESCROW v3.0
;; FunC Smart Contract for Telegram Ads Marketplace
;;
;; CRITICAL FIX: Uses msg_value for funding verification (not my_balance)
;;
;; Flow:
;; 1. Contract deployed with deal params
;; 2. Advertiser sends TON >= total_amount → check msg_value → FUNDED
;; 3. Platform sends op=RELEASE → all funds to platform wallet
;; 4. Refund: platform anytime OR advertiser after deadline
;; 5. Dispute: advertiser/publisher → DISPUTED. Platform resolves.
;;
;; On release, ALL funds go to platform wallet. Backend handles:
;;   - Publisher amount → in-app balance
;;   - Platform fee → platform keeps
;;   - Referral fee → referrer's in-app balance
;; ═══════════════════════════════════════════════════════════════════════════════

#include "stdlib.fc";

;; ═══ Storage Layout ═══
;; uint8    status
;; uint256  deal_id            ;; SHA256 hash of string dealId (collision-resistant)
;; addr     advertiser
;; addr     publisher
;; addr     platform_wallet
;; coins    total_amount
;; coins    publisher_amount
;; uint32   deadline           ;; unix timestamp
;; uint32   created_at

;; ═══ Status Codes ═══
const int STATUS_PENDING  = 0;
const int STATUS_FUNDED   = 1;
const int STATUS_RELEASED = 2;
const int STATUS_REFUNDED = 3;
const int STATUS_DISPUTED = 4;

;; ═══ Operation Codes (ASCII-based for readability) ═══
const int OP_FUND    = 0x746F6E46;   ;; "tonF" - explicit fund message
const int OP_RELEASE = 0x72656C73;   ;; "rels" - release funds
const int OP_REFUND  = 0x72656675;   ;; "refu" - refund to advertiser
const int OP_DISPUTE = 0x64697370;   ;; "disp" - freeze funds
const int OP_RESOLVE = 0x7265736F;   ;; "reso" - platform resolves dispute
const int OP_EXTEND  = 0x65787464;   ;; "extd" - extend deadline

;; ═══ Error Codes ═══
const int ERR_UNAUTHORIZED       = 101;
const int ERR_INVALID_STATE      = 102;
const int ERR_INSUFFICIENT_FUNDS = 103;
const int ERR_DEADLINE_NOT_MET   = 104;
const int ERR_INVALID_OP         = 106;
const int ERR_INVALID_DEADLINE   = 108;

;; ═══ Constants ═══
const int MIN_TON_FOR_STORAGE = 10000000;   ;; 0.01 TON

;; ═══ Utility Functions ═══
;; Compare two slices for equality (TVM SDEQ instruction)
int equal_slices(slice a, slice b) asm "SDEQ";

;; ═══════════════════════════════════════════════════════════════════════════════
;; STORAGE FUNCTIONS
;; ═══════════════════════════════════════════════════════════════════════════════
;; Layout (split across 2 cells to avoid overflow):
;; Cell 1: status (8) + deal_id (256) + advertiser (267) + publisher (267) + ref->Cell2
;; Cell 2: platform (267) + total_amount (coins) + publisher_amount (coins) + deadline (32) + created_at (32)

global int ctx_status;
global int ctx_deal_id;
global slice ctx_advertiser;
global slice ctx_publisher;
global slice ctx_platform;
global int ctx_total_amount;
global int ctx_publisher_amount;
global int ctx_deadline;
global int ctx_created_at;

() load_data() impure inline {
    slice ds = get_data().begin_parse();
    ctx_status = ds~load_uint(8);
    ctx_deal_id = ds~load_uint(256);
    ctx_advertiser = ds~load_msg_addr();
    ctx_publisher = ds~load_msg_addr();
    ;; Load remaining data from reference cell
    slice ds2 = ds~load_ref().begin_parse();
    ctx_platform = ds2~load_msg_addr();
    ctx_total_amount = ds2~load_coins();
    ctx_publisher_amount = ds2~load_coins();
    ctx_deadline = ds2~load_uint(32);
    ctx_created_at = ds2~load_uint(32);
}

() save_data() impure inline {
    cell data2 = begin_cell()
        .store_slice(ctx_platform)
        .store_coins(ctx_total_amount)
        .store_coins(ctx_publisher_amount)
        .store_uint(ctx_deadline, 32)
        .store_uint(ctx_created_at, 32)
    .end_cell();

    set_data(begin_cell()
        .store_uint(ctx_status, 8)
        .store_uint(ctx_deal_id, 256)
        .store_slice(ctx_advertiser)
        .store_slice(ctx_publisher)
        .store_ref(data2)
    .end_cell());
}

;; ═══════════════════════════════════════════════════════════════════════════════
;; HELPERS
;; ═══════════════════════════════════════════════════════════════════════════════

() send_with_comment(slice to_addr, int amount, slice comment, int mode) impure inline {
    cell body = begin_cell()
        .store_uint(0, 32)
        .store_slice(comment)
    .end_cell();

    cell msg = begin_cell()
        .store_uint(0x18, 6)           ;; nobounce
        .store_slice(to_addr)
        .store_coins(amount)
        .store_uint(1, 1 + 4 + 4 + 64 + 32 + 1 + 1)
        .store_ref(body)
    .end_cell();
    send_raw_message(msg, mode);
}

;; ═══════════════════════════════════════════════════════════════════════════════
;; HANDLERS
;; ═══════════════════════════════════════════════════════════════════════════════

;; FUND: Advertiser deposits TON to escrow
;; CRITICAL: Check msg_value, NOT my_balance!
() handle_fund(slice sender, int msg_value) impure inline {
    throw_unless(ERR_UNAUTHORIZED, equal_slices(sender, ctx_advertiser));
    throw_unless(ERR_INVALID_STATE, ctx_status == STATUS_PENDING);

    ;; CRITICAL FIX: Check incoming msg_value, not contract balance!
    ;; This prevents the bounce bug when gas fees reduce my_balance below threshold
    throw_unless(ERR_INSUFFICIENT_FUNDS, msg_value >= ctx_total_amount);

    ctx_status = STATUS_FUNDED;
    save_data();
}

;; RELEASE: Platform releases funds after successful deal
() handle_release(slice sender) impure inline {
    throw_unless(ERR_UNAUTHORIZED, equal_slices(sender, ctx_platform));
    throw_unless(ERR_INVALID_STATE, ctx_status == STATUS_FUNDED);

    ctx_status = STATUS_RELEASED;
    save_data();

    ;; Send ALL balance to platform wallet (mode 128 = send remaining, 32 = destroy if zero)
    send_with_comment(ctx_platform, 0, "escrow_release", 128 + 32);
}

;; REFUND: Return funds to advertiser
() handle_refund(slice sender) impure inline {
    int is_platform = equal_slices(sender, ctx_platform);
    int is_advertiser = equal_slices(sender, ctx_advertiser);

    throw_unless(ERR_UNAUTHORIZED, is_platform | is_advertiser);
    throw_unless(ERR_INVALID_STATE, ctx_status == STATUS_FUNDED);

    ;; Advertiser can only refund after deadline
    if (is_advertiser) {
        throw_unless(ERR_DEADLINE_NOT_MET, now() >= ctx_deadline);
    }

    ctx_status = STATUS_REFUNDED;
    save_data();

    ;; Send ALL balance back to advertiser
    send_with_comment(ctx_advertiser, 0, "escrow_refund", 128 + 32);
}

;; DISPUTE: Freeze funds for dispute resolution
() handle_dispute(slice sender) impure inline {
    int is_advertiser = equal_slices(sender, ctx_advertiser);
    int is_publisher = equal_slices(sender, ctx_publisher);

    throw_unless(ERR_UNAUTHORIZED, is_advertiser | is_publisher);
    throw_unless(ERR_INVALID_STATE, ctx_status == STATUS_FUNDED);

    ctx_status = STATUS_DISPUTED;
    save_data();
}

;; RESOLVE: Platform resolves dispute
() handle_resolve(slice sender, slice in_msg_body) impure inline {
    throw_unless(ERR_UNAUTHORIZED, equal_slices(sender, ctx_platform));
    throw_unless(ERR_INVALID_STATE, ctx_status == STATUS_DISPUTED);

    ;; resolution: 0 = refund advertiser, 1 = release to platform (publisher wins)
    int resolution = in_msg_body~load_uint(1);

    if (resolution == 0) {
        ;; Refund advertiser
        ctx_status = STATUS_REFUNDED;
        save_data();
        send_with_comment(ctx_advertiser, 0, "dispute_refund", 128 + 32);
    } else {
        ;; Release to platform (publisher wins)
        ctx_status = STATUS_RELEASED;
        save_data();
        send_with_comment(ctx_platform, 0, "dispute_release", 128 + 32);
    }
}

;; EXTEND: Platform extends deadline
() handle_extend(slice sender, slice in_msg_body) impure inline {
    throw_unless(ERR_UNAUTHORIZED, equal_slices(sender, ctx_platform));
    throw_unless(ERR_INVALID_STATE, (ctx_status == STATUS_FUNDED) | (ctx_status == STATUS_DISPUTED));

    int new_deadline = in_msg_body~load_uint(32);
    throw_unless(ERR_INVALID_DEADLINE, new_deadline > now());

    ctx_deadline = new_deadline;
    save_data();
}

;; ═══════════════════════════════════════════════════════════════════════════════
;; MAIN RECEIVER
;; ═══════════════════════════════════════════════════════════════════════════════

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);

    ;; ═══ BOUNCE HANDLING ═══
    ;; If a release/refund message bounced, revert status to FUNDED
    if (flags & 1) {
        load_data();
        if ((ctx_status == STATUS_RELEASED) | (ctx_status == STATUS_REFUNDED)) {
            ctx_status = STATUS_FUNDED;
            save_data();
        }
        return ();
    }

    slice sender = cs~load_msg_addr();
    load_data();

    ;; ═══ AUTO-FUND: Empty body = funding attempt ═══
    if (in_msg_body.slice_empty?()) {
        if (ctx_status == STATUS_PENDING) {
            handle_fund(sender, msg_value);
        }
        ;; If already funded, accept excess silently
        return ();
    }

    int op = in_msg_body~load_uint(32);

    ;; ═══ TEXT COMMENT (op=0): Also treat as funding ═══
    if (op == 0) {
        if (ctx_status == STATUS_PENDING) {
            handle_fund(sender, msg_value);
        }
        return ();
    }

    ;; All other ops require query_id
    int query_id = in_msg_body~load_uint(64);

    ;; ═══ EXPLICIT FUND (op=0x746F6E46 "tonF") ═══
    if (op == OP_FUND) {
        handle_fund(sender, msg_value);
        return ();
    }

    ;; ═══ RELEASE (op=0x72656C73 "rels") ═══
    if (op == OP_RELEASE) {
        handle_release(sender);
        return ();
    }

    ;; ═══ REFUND (op=0x72656675 "refu") ═══
    if (op == OP_REFUND) {
        handle_refund(sender);
        return ();
    }

    ;; ═══ DISPUTE (op=0x64697370 "disp") ═══
    if (op == OP_DISPUTE) {
        handle_dispute(sender);
        return ();
    }

    ;; ═══ RESOLVE (op=0x7265736F "reso") ═══
    if (op == OP_RESOLVE) {
        handle_resolve(sender, in_msg_body);
        return ();
    }

    ;; ═══ EXTEND DEADLINE (op=0x65787464 "extd") ═══
    if (op == OP_EXTEND) {
        handle_extend(sender, in_msg_body);
        return ();
    }

    throw(ERR_INVALID_OP);
}

;; ═══════════════════════════════════════════════════════════════════════════════
;; GET METHODS
;; ═══════════════════════════════════════════════════════════════════════════════

;; Full escrow data
(int, int, slice, slice, slice, int, int, int, int) get_escrow_data() method_id {
    load_data();
    return (ctx_status, ctx_deal_id, ctx_advertiser, ctx_publisher, ctx_platform,
            ctx_total_amount, ctx_publisher_amount, ctx_deadline, ctx_created_at);
}

int get_status() method_id {
    load_data();
    return ctx_status;
}

int get_deal_id() method_id {
    load_data();
    return ctx_deal_id;
}

int get_total_amount() method_id {
    load_data();
    return ctx_total_amount;
}

int get_publisher_amount() method_id {
    load_data();
    return ctx_publisher_amount;
}

int get_platform_fee() method_id {
    load_data();
    return ctx_total_amount - ctx_publisher_amount;
}

int get_deadline() method_id {
    load_data();
    return ctx_deadline;
}

int is_expired() method_id {
    load_data();
    return now() >= ctx_deadline;
}

int get_locked_balance() method_id {
    return get_balance().pair_first();
}
